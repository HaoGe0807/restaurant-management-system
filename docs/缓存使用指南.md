# 缓存使用指南

## 概述

项目实现了**两级缓存架构**：
- **第一级：本地缓存（Caffeine）** - 快速访问，适合高频读取的数据
- **第二级：Redis 缓存** - 分布式共享，适合跨服务数据共享

## 架构设计

```
┌─────────────────┐
│   应用层调用     │
└────────┬────────┘
         │
┌────────▼────────────────────────┐
│   MultiLevelCacheManager        │
│   (两级缓存管理器)              │
└────────┬────────────────────────┘
         │
    ┌────┴────┐
    │         │
┌───▼───┐ ┌──▼────┐
│本地缓存│ │ Redis │
│Caffeine│ │缓存   │
└───────┘ └───────┘
    │         │
    └────┬────┘
         │
┌────────▼────────┐
│   数据库 MySQL   │
└─────────────────┘
```

## 缓存策略

### 读取流程（Cache-Aside 模式）

1. **先查本地缓存**（Caffeine）
   - 命中：直接返回，最快
   - 未命中：继续下一步

2. **再查 Redis 缓存**
   - 命中：返回数据，并回填本地缓存
   - 未命中：继续下一步

3. **查数据库**
   - 从数据库加载数据
   - 写入两级缓存（本地 + Redis）
   - 返回数据

### 写入流程

1. **写入数据库**
2. **更新缓存**（可选）
   - 更新模式：写入两级缓存
   - 删除模式：清除两级缓存（推荐）

## 配置说明

### application.yml 配置

```yaml
# 本地缓存配置（Caffeine）
cache:
  local:
    max-size: 1000  # 最大缓存条目数
    expire-after-write-seconds: 300  # 写入后过期时间（秒）
    expire-after-access-seconds: 180  # 访问后过期时间（秒）

# Redis 缓存配置
cache:
  redis:
    default-expiration-seconds: 3600  # 默认过期时间（秒）

# Redis 连接配置
spring:
  redis:
    host: localhost
    port: 6379
    password: ""  # 如果 Redis 没有密码，使用空字符串
    database: 0
```

## 使用示例

### 1. 在仓储层使用缓存

```java
@Repository
@RequiredArgsConstructor
public class ProductRepositoryImpl implements ProductRepository {
    
    private final ProductMapper productMapper;
    private final MultiLevelCacheManager cacheManager;
    
    private static final String CACHE_NAME = "product:spu";
    
    @Override
    public Optional<ProductSpu> findBySpuId(String spuId) {
        String cacheKey = "spu:" + spuId;
        
        // 使用两级缓存查询
        ProductSpu spu = cacheManager.get(
            CACHE_NAME,
            cacheKey,
            () -> {
                // 缓存未命中时，从数据库加载
                return productMapper.selectOne(
                    new LambdaQueryWrapper<ProductSpu>()
                        .eq(ProductSpu::getSpuId, spuId)
                );
            }
        );
        
        return Optional.ofNullable(spu);
    }
    
    @Override
    public ProductSpu save(ProductSpu productSpu) {
        // 保存到数据库
        if (productSpu.getId() == null) {
            productMapper.insert(productSpu);
        } else {
            productMapper.updateById(productSpu);
        }
        
        // 清除相关缓存（推荐：删除模式）
        String cacheKey = "spu:" + productSpu.getSpuId();
        cacheManager.evict(CACHE_NAME, cacheKey);
        
        return productSpu;
    }
}
```

### 2. 在应用服务层使用缓存

```java
@Service
@RequiredArgsConstructor
public class ProductApplicationService {
    
    private final ProductDomainService productDomainService;
    private final MultiLevelCacheManager cacheManager;
    
    private static final String CACHE_NAME = "product:spu";
    
    public ProductSpu getProduct(String spuId) {
        String cacheKey = "spu:" + spuId;
        
        return cacheManager.get(
            CACHE_NAME,
            cacheKey,
            () -> productDomainService.getProductSpu(spuId)
        );
    }
    
    @Transactional
    public ProductSpu updateProduct(String spuId, SaveProductCommand command) {
        // 更新商品
        ProductSpu product = productDomainService.updateProduct(...);
        
        // 清除缓存
        String cacheKey = "spu:" + spuId;
        cacheManager.evict(CACHE_NAME, cacheKey);
        
        return product;
    }
}
```

### 3. 使用 Spring Cache 注解（简化版）

```java
@Service
@RequiredArgsConstructor
public class ProductApplicationService {
    
    private final ProductDomainService productDomainService;
    
    @Cacheable(value = "product:spu", key = "'spu:' + #spuId")
    public ProductSpu getProduct(String spuId) {
        return productDomainService.getProductSpu(spuId);
    }
    
    @CacheEvict(value = "product:spu", key = "'spu:' + #spuId")
    @Transactional
    public ProductSpu updateProduct(String spuId, SaveProductCommand command) {
        return productDomainService.updateProduct(...);
    }
}
```

## 缓存命名规范

建议使用以下命名规范：

```
{模块}:{实体}:{标识}
```

示例：
- `product:spu:spu:SPU123456` - 商品 SPU
- `product:sku:sku:SKU123456` - 商品 SKU
- `inventory:sku:SKU123456` - 库存信息
- `order:order:ORDER123456` - 订单信息

## 缓存更新策略

### 1. 删除模式（推荐）

```java
// 更新数据后，删除缓存
cacheManager.evict(CACHE_NAME, cacheKey);
```

**优点**：
- 简单，不会出现数据不一致
- 下次查询时自动加载最新数据

**缺点**：
- 如果数据更新频繁但查询不频繁，可能浪费缓存

### 2. 更新模式

```java
// 更新数据后，更新缓存
cacheManager.put(CACHE_NAME, cacheKey, updatedData);
```

**优点**：
- 下次查询时直接命中缓存

**缺点**：
- 需要确保缓存数据与数据库一致
- 如果更新失败，缓存可能过期

## 注意事项

### 1. 缓存穿透

**问题**：查询不存在的数据，每次都查数据库

**解决方案**：
```java
// 缓存 null 值，设置较短的过期时间
if (data == null) {
    cacheManager.put(CACHE_NAME, cacheKey, NULL_VALUE, 60); // 60秒过期
}
```

### 2. 缓存雪崩

**问题**：大量缓存同时过期，导致数据库压力激增

**解决方案**：
- 设置随机的过期时间
- 使用分布式锁，只允许一个请求查数据库

### 3. 缓存击穿

**问题**：热点数据过期，大量请求同时查数据库

**解决方案**：
- 使用分布式锁
- 设置永不过期的热点数据，后台异步更新

### 4. 数据一致性

**问题**：缓存数据与数据库不一致

**解决方案**：
- 使用删除模式，而不是更新模式
- 在事务提交后清除缓存
- 使用消息队列通知其他服务清除缓存

## 性能优化建议

1. **本地缓存**：适合高频访问、数据量小的数据（如商品基本信息）
2. **Redis 缓存**：适合跨服务共享的数据（如库存信息）
3. **缓存预热**：应用启动时，预加载热点数据
4. **缓存监控**：监控缓存命中率，优化缓存策略

## 监控指标

建议监控以下指标：
- 本地缓存命中率
- Redis 缓存命中率
- 缓存大小
- 缓存过期时间
- 缓存更新频率

## 总结

- **本地缓存（Caffeine）**：快速、单机、适合高频读取
- **Redis 缓存**：分布式、共享、适合跨服务
- **两级缓存**：先本地后 Redis，兼顾性能和分布式
- **更新策略**：推荐使用删除模式，简单可靠

